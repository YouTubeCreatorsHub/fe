name: Project Board Automation

on:
 issues:
   types: [opened, reopened, closed]
 pull_request:
   types: [opened, reopened, closed]

jobs:
 project_automation:
   runs-on: ubuntu-latest
   permissions:
     issues: write
     pull-requests: write
     repository-projects: write
     contents: read
   steps:
     - uses: actions/github-script@v7
       with:
         github-token: ${{ github.token }}
         script: |
           // ÌîÑÎ°úÏ†ùÌä∏ Í¥ÄÎ†® ÏÉÅÏàò Ï†ïÏùò
           const PROJECT = {
             ID: 'PVT_kwDOC0FCP84AsibV',              // ÌîÑÎ°úÏ†ùÌä∏ ID
             STATUS_FIELD_ID: 'PVTSSF_lADOC0FCP84AsibVzgjchQE',  // ÏÉÅÌÉú ÌïÑÎìú ID
             COLUMNS: {
               BACKLOG: '17052d30',        // üìã Backlog
               SPRINT_BACKLOG: '2b4b3335', // üìÖ Sprint Backlog
               IN_PROGRESS: 'dc54b4f8',    // üíª In Progress
               IN_REVIEW: '3fdc4773',      // üëÄ In Review
               DONE: '98236657'            // ‚úÖ Done
             }
           };

           async function findProjectV2Item(contentId) {
             const query = `
               query($projectId: ID!, $contentId: ID!) {
                 node(id: $projectId) {
                   ... on ProjectV2 {
                     items(first: 1, filter: {contentId: $contentId}) {
                       nodes {
                         id
                       }
                     }
                   }
                 }
               }
             `;
             
             const result = await github.graphql(query, {
               projectId: PROJECT.ID,
               contentId: contentId
             });
             
             return result?.node?.items?.nodes[0]?.id;
           }

           async function moveIssueToColumn(contentId, columnId) {
             try {
               const addMutation = `
                 mutation($projectId: ID!, $contentId: ID!) {
                   addProjectV2ItemById(input: {
                     projectId: $projectId
                     contentId: $contentId
                   }) {
                     item {
                       id
                     }
                   }
                 }
               `;

               const { addProjectV2ItemById } = await github.graphql(addMutation, {
                 projectId: PROJECT.ID,
                 contentId: contentId
               });

               const itemId = addProjectV2ItemById?.item?.id || await findProjectV2Item(contentId);

               if (itemId) {
                 const updateMutation = `
                   mutation(
                     $projectId: ID!
                     $itemId: ID!
                     $fieldId: ID!
                     $optionId: String!
                   ) {
                     updateProjectV2ItemFieldValue(
                       input: {
                         projectId: $projectId
                         itemId: $itemId
                         fieldId: $fieldId
                         value: { 
                           singleSelectOptionId: $optionId
                         }
                       }
                     ) {
                       projectV2Item {
                         id
                       }
                     }
                   }
                 `;

                 await github.graphql(updateMutation, {
                   projectId: PROJECT.ID,
                   itemId: itemId,
                   fieldId: PROJECT.STATUS_FIELD_ID,
                   optionId: columnId
                 });
               }
             } catch (error) {
               console.error('Error:', error);
             }
           }

           // Ïù¥Ïäà Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
           if (context.eventName === 'issues') {
             const issueId = context.payload.issue.node_id;
             const repo = context.payload.repository.name.toLowerCase();
             
             if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
               if (repo === 'fe') {
                 await moveIssueToColumn(issueId, PROJECT.COLUMNS.BACKLOG);
               }
               else if (repo === 'be') {
                 await moveIssueToColumn(issueId, PROJECT.COLUMNS.SPRINT_BACKLOG);
               }
             }
             else if (context.payload.action === 'closed') {
               await moveIssueToColumn(issueId, PROJECT.COLUMNS.DONE);
             }
           }

           // PR Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ 
           if (context.eventName === 'pull_request') {
             const prId = context.payload.pull_request.node_id;
             
             if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
               await moveIssueToColumn(prId, PROJECT.COLUMNS.IN_REVIEW);
             }
             else if (context.payload.action === 'closed' && context.payload.pull_request.merged) {
               await moveIssueToColumn(prId, PROJECT.COLUMNS.DONE);
             }
           }

 add_reviewers:
   runs-on: ubuntu-latest
   if: github.event_name == 'pull_request' && github.event.action == 'opened'
   permissions:
     pull-requests: write
   steps:
     - uses: actions/github-script@v7
       with:
         github-token: ${{ github.token }}
         script: |
           try {
             await github.rest.pulls.requestReviewers({
               owner: context.repo.owner,
               repo: context.repo.repo,
               pull_number: context.payload.pull_request.number,
               reviewers: ['choco5958', 'lim3873', 'tlswltjq']
             });
           } catch (error) {
             console.error('Error adding reviewers:', error);
           }

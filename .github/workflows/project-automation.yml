name: Project Board Automation

on:
  issues:
    types: [opened, reopened, closed]
  pull_request:
    types: [opened, reopened, closed]

jobs:
  project_automation:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      organization-projects: write
      repository-projects: write
      contents: read
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTO_ACTIONS }}
          script: |
            async function fetchProjectDetails() {
                const query = `
                  query($org: String!, $projectNumber: Int!) {
                    organization(login: $org) {
                      projectV2(number: $projectNumber) {
                        id
                        fields(first: 20) {
                          nodes {
                            ... on ProjectV2SingleSelectField {
                              id
                              name
                              options {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
              
                try {
                  const variables = {
                    org: "YouTubeCreatorsHub",  // 조직 이름
                    projectNumber: 1            // 프로젝트 번호 (칸반 보드가 있는 프로젝트 번호)
                  };
              
                  console.log('GraphQL Variables:', JSON.stringify(variables));
                  const result = await github.graphql(query, variables);
                  console.log('GraphQL Result:', JSON.stringify(result));
              
                  const project = result.organization.projectV2;
                  if (!project) throw new Error('Project not found');
                  
                  const statusField = project.fields.nodes.find(field => 
                    field.name === 'Status' && field.options
                  );
                  if (!statusField) throw new Error('Status field not found');
              
                  const columns = {
                    BACKLOG: statusField.options.find(opt => opt.name === 'Backlog')?.id,
                    SPRINT_BACKLOG: statusField.options.find(opt => opt.name === 'Sprint Backlog')?.id,
                    IN_PROGRESS: statusField.options.find(opt => opt.name === 'In Progress')?.id,
                    IN_REVIEW: statusField.options.find(opt => opt.name === 'In Review')?.id,
                    DONE: statusField.options.find(opt => opt.name === 'Done')?.id
                  };
              
                  console.log('Columns:', JSON.stringify(columns));
              
                  return {
                    projectId: project.id, // 프로젝트 ID
                    statusFieldId: statusField.id,
                    columns
                  };
                } catch (error) {
                  console.error('Error in fetchProjectDetails:', error);
                  throw error;
                }
              }
    

            async function moveIssueToColumn(contentId, columnId) {
              if (!PROJECT) {
                PROJECT = await fetchProjectDetails();
                if (!PROJECT) throw new Error('Failed to fetch project details');
              }

              console.log('Moving item to column:', {
                contentId,
                columnId,
                projectId: PROJECT.projectId,
                statusFieldId: PROJECT.statusFieldId
              });

              try {
                const addMutation = `
                  mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: {
                      projectId: $projectId
                      contentId: $contentId
                    }) {
                      item {
                        id
                      }
                    }
                  }
                `;

                const addResult = await github.graphql(addMutation, {
                  projectId: PROJECT.projectId,
                  contentId
                });

                const itemId = addResult.addProjectV2ItemById?.item?.id;
                if (!itemId) throw new Error('Failed to add item to project');

                const updateMutation = `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(
                      input: {
                        projectId: $projectId
                        itemId: $itemId
                        fieldId: $fieldId
                        value: { singleSelectOptionId: $optionId }
                      }
                    ) {
                      projectV2Item {
                        id
                      }
                    }
                  }
                `;

                await github.graphql(updateMutation, {
                  projectId: PROJECT.projectId,
                  itemId,
                  fieldId: PROJECT.statusFieldId,
                  optionId: columnId
                });

                console.log('Successfully moved item to column');
              } catch (error) {
                console.error('Error in moveIssueToColumn:', error);
                throw error;
              }
            }

            let PROJECT;

            async function processEvent() {
              try {
                PROJECT = await fetchProjectDetails();
                
                if (context.eventName === 'issues') {
                  const issueId = context.payload.issue.node_id;
                  const repo = context.payload.repository.name.toLowerCase();
                  
                  if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
                    if (repo === 'fe') {
                      await moveIssueToColumn(issueId, PROJECT.columns.BACKLOG);
                    } else if (repo === 'be') {
                      await moveIssueToColumn(issueId, PROJECT.columns.SPRINT_BACKLOG);
                    }
                  } else if (context.payload.action === 'closed') {
                    await moveIssueToColumn(issueId, PROJECT.columns.DONE);
                  }
                }

                if (context.eventName === 'pull_request') {
                  const prId = context.payload.pull_request.node_id;
                  
                  if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
                    await moveIssueToColumn(prId, PROJECT.columns.IN_REVIEW);
                  } else if (context.payload.action === 'closed' && context.payload.pull_request.merged) {
                    await moveIssueToColumn(prId, PROJECT.columns.DONE);
                  }
                }
              } catch (error) {
                console.error('Error in processEvent:', error);
                throw error;
              }
            }

            await processEvent();

name: Project Board Automation

on:
  issues:
    types: [opened, reopened, closed]
  pull_request:
    types: [opened, reopened, closed]

jobs:
  project_automation:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      organization-projects: write
      repository-projects: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTO_ACTIONS }}
          script: |
            const STATUS_FIELD_ID = 'Status'; // Replace with your actual Status field ID
            
            // First fetch the project ID and field information
            async function getProjectInfo() {
              const query = `
                query($org: String!, $number: Int!) {
                  organization(login: $org) {
                    projectV2(number: $number) {
                      id
                      fields(first: 20) {
                        nodes {
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const result = await github.graphql(query, {
                org: 'YouTubeCreatorsHub',
                number: 1 // Your project number
              });
              
              return result.organization.projectV2;
            }
            
            // Add item to project
            async function addItemToProject(projectId, contentId) {
              const mutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: {
                    projectId: $projectId,
                    contentId: $contentId
                  }) {
                    item {
                      id
                    }
                  }
                }
              `;
              
              const result = await github.graphql(mutation, {
                projectId,
                contentId
              });
              
              return result.addProjectV2ItemById.item.id;
            }
            
            // Update item's status
            async function updateItemStatus(projectId, itemId, statusId) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $statusId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: "${STATUS_FIELD_ID}",
                    value: { singleSelectOptionId: $statusId }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;
              
              await github.graphql(mutation, {
                projectId,
                itemId,
                statusId
              });
            }
            
            try {
              // Get project information
              const project = await getProjectInfo();
              const statusField = project.fields.nodes.find(f => f.name === 'Status');
              
              // Map status names to IDs
              const statusMap = {
                BACKLOG: statusField.options.find(o => o.name === 'Backlog').id,
                SPRINT_BACKLOG: statusField.options.find(o => o.name === 'Sprint Backlog').id,
                IN_PROGRESS: statusField.options.find(o => o.name === 'In Progress').id,
                IN_REVIEW: statusField.options.find(o => o.name === 'In Review').id,
                DONE: statusField.options.find(o => o.name === 'Done').id
              };
              
              let contentId, targetStatus;
              
              if (context.eventName === 'issues') {
                contentId = context.payload.issue.node_id;
                const repo = context.payload.repository.name.toLowerCase();
                
                if (context.payload.action === 'opened') {
                  targetStatus = repo === 'fe' ? statusMap.BACKLOG : statusMap.SPRINT_BACKLOG;
                } else if (context.payload.action === 'closed') {
                  targetStatus = statusMap.DONE;
                }
              } else if (context.eventName === 'pull_request') {
                contentId = context.payload.pull_request.node_id;
                
                if (context.payload.action === 'opened') {
                  targetStatus = statusMap.IN_REVIEW;
                } else if (context.payload.action === 'closed' && context.payload.pull_request.merged) {
                  targetStatus = statusMap.DONE;
                }
              }
              
              if (contentId && targetStatus) {
                const itemId = await addItemToProject(project.id, contentId);
                await updateItemStatus(project.id, itemId, targetStatus);
              }
              
            } catch (error) {
              console.error('Error:', error.message);
              throw error;
            }
